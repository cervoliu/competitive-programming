{
    "maxflow": {
        "prefix": "maxflow",
        "scope": "cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "typedef long long ll;",
            "",
            "const int N = 5e4 + 5, M = 1e5 + 5;",
            "const ll INF = 1e18;",
            "int n, m, s, t;",
            "",
            "int tot = 1, to[M], nxt[M], lst[N];",
            "ll cap[M];",
            "",
            "int level[N], cur[N];",
            "",
            "void link(int u,int v,ll w) {",
            "  to[++tot] = v;",
            "  nxt[tot] = lst[u];",
            "  lst[u] = tot;",
            "  cap[tot] = w;",
            "}",
            "",
            "bool bfs() {",
            "  memset(level, 0, sizeof(level));",
            "  queue<int> q;",
            "  q.push(s);",
            "  level[s] = 1;",
            "  while(!q.empty()) {",
            "    int u = q.front(); q.pop();",
            "    for (int i = lst[u]; i; i = nxt[i]) {",
            "      int v = to[i];",
            "      if (cap[i] && !level[v]) {",
            "        level[v] = level[u] + 1;",
            "        q.push(v);",
            "      }",
            "    }",
            "  }",
            "  return level[t] > 0;",
            "}",
            "",
            "ll dfs(int u, ll flow) {",
            "  if (u == t) return flow;",
            "  ll ans = 0;",
            "  for (int &i = cur[u]; i; i = nxt[i]) {",
            "    int v = to[i];",
            "    if (cap[i] && level[v] == level[u] + 1) {",
            "      ll f = dfs(v, min(flow - ans, cap[i]));",
            "      if (f > 0) {",
            "        ans += f;",
            "        cap[i] -= f;",
            "        cap[i ^ 1] += f;",
            "      }",
            "    }",
            "  }",
            "  return ans;",
            "}",
            "",
            "ll dinic(int s, int t) {",
            "  ll res = 0;",
            "  while(bfs()) {",
            "    memcpy(cur, lst ,sizeof(lst));",
            "    ll x = 0;",
            "    while((x = dfs(s, INF))) {",
            "      res += x;",
            "    }",
            "  }",
            "  return res;",
            "}",
            "",
            "int main() {",
            "  freopen(\"input.txt\", \"r\", stdin);",
            "  scanf(\"%d%d%d%d\", &n, &m, &s, &t);",
            "  for (int i = 1; i <= m; ++i) {",
            "    int u, v, w;",
            "    scanf(\"%d%d%d\", &u, &v, &w);",
            "    link(u, v, w);",
            "    link(v, u, 0);",
            "  }",
            "",
            "  ll ans = 0;",
            "",
            "  ans = dinic(s, t);",
            "",
            "  printf(\"%lld\\n\", ans);",
            "  return 0;",
            "}"
        ]
    },
    "hungarian": {
        "prefix": "hungarian",
        "scope": "cpp",
        "body": [
            "#include <cstdio>",
            "#include <algorithm>",
            "",
            "constexpr int N = 205;",
            "using namespace std;",
            "",
            "// st: \u65f6\u95f4\u6233, \u7528\u4e8e\u6807\u8bb0\u6bcf\u8f6e\u5339\u914d",
            "// a[i][j]: \u90bb\u63a5\u8868\uff0ca[i][0] \u5b58\u50a8 i \u7684\u90bb\u5c45\u4e2a\u6570\uff0ca[i][1..a[i][0]] \u5b58\u50a8\u90bb\u5c45\u8282\u70b9",
            "// b[i]: \u53f3\u4fa7\u8282\u70b9 i \u5339\u914d\u7684\u5de6\u4fa7\u8282\u70b9\uff080\u8868\u793a\u672a\u5339\u914d\uff09",
            "// bz[i]: \u8282\u70b9 i \u7684\u8bbf\u95ee\u65f6\u95f4\u6233, \u7528\u4e8e\u907f\u514d\u91cd\u590d\u8bbf\u95ee",
            "int st, a[N][N], b[N], bz[N];",
            "",
            "bool match(int v)",
            "{",
            "    // \u5982\u679c\u8fd9\u4e2a\u8282\u70b9\u5728\u672c\u8f6e\u5df2\u7ecf\u8bbf\u95ee\u8fc7\uff0c\u76f4\u63a5\u8fd4\u56defalse\uff08\u907f\u514d\u6b7b\u5faa\u73af\uff09",
            "    if(bz[v] == st) return 0;",
            "    bz[v] = st; // \u6807\u8bb0\u4e3a\u5df2\u8bbf\u95ee",
            "",
            "    // \u904d\u5386v\u7684\u6240\u6709\u90bb\u5c45",
            "    for(int i = 1; i <= a[v][0]; i++)",
            "    {",
            "        int u = a[v][i]; // u\u662fv\u7684\u90bb\u5c45",
            "        if(!b[u] || match(b[u]))",
            "        {",
            "            b[u] = v; // \u5c06u\u5339\u914d\u7ed9v",
            "            return 1; // \u627e\u5230\u589e\u5e7f\u8def\u5f84",
            "        }",
            "    }",
            "    return 0; // \u6ca1\u6709\u627e\u5230\u589e\u5e7f\u8def\u5f84",
            "}",
            "int main()",
            "{",
            "    int n, k, x, y, ans = 0;",
            "    scanf(\"%d %d\", &n, &k);",
            "    for(int i = 1; i <= k; i++)",
            "    {",
            "        scanf(\"%d %d\", &x, &y);",
            "        y += n;",
            "        a[x][++a[x][0]] = y;",
            "        a[y][++a[y][0]] = x;",
            "    }",
            "    for(st = 1; st <= n; st++)",
            "        if(match(st)) ans++;",
            "    printf(\"%d\", ans);",
            "}"
        ]
    },
    "fastio": {
        "prefix": "fastio",
        "scope": "cpp",
        "body": [
            "struct IO {",
            "#define MAXSIZE (1 << 20)",
            "#define isdigit(x) (x >= '0' && x <= '9')",
            "  char buf[MAXSIZE], *p1, *p2;",
            "  char pbuf[MAXSIZE], *pp;",
            "#if DEBUG",
            "#else",
            "  IO() : p1(buf), p2(buf), pp(pbuf) {}",
            "",
            "  ~IO() { fwrite(pbuf, 1, pp - pbuf, stdout); }",
            "#endif",
            "  char gc() {",
            "#if DEBUG",
            "    return getchar();",
            "#endif",
            "    if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, MAXSIZE, stdin);",
            "    return p1 == p2 ? ' ' : *p1++;",
            "  }",
            "",
            "  bool blank(char ch) {",
            "    return ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t';",
            "  }",
            "",
            "  template <class T>",
            "  void read(T &x) {",
            "    double tmp = 1;",
            "    bool sign = 0;",
            "    x = 0;",
            "    char ch = gc();",
            "    for (; !isdigit(ch); ch = gc())",
            "      if (ch == '-') sign = 1;",
            "    for (; isdigit(ch); ch = gc()) x = x * 10 + (ch - '0');",
            "    if (ch == '.')",
            "      for (ch = gc(); isdigit(ch); ch = gc())",
            "        tmp /= 10.0, x += tmp * (ch - '0');",
            "    if (sign) x = -x;",
            "  }",
            "",
            "",
            "  template <class T>",
            "  T read() {",
            "    T x;",
            "    read(x);",
            "    return x;",
            "  }",
            "",
            "  void read(char *s) {",
            "    char ch = gc();",
            "    for (; blank(ch); ch = gc());",
            "    for (; !blank(ch); ch = gc()) *s++ = ch;",
            "    *s = 0;",
            "  }",
            "",
            "  void read(char &c) { for (c = gc(); blank(c); c = gc()); }",
            "",
            "  void push(const char &c) {",
            "#if DEBUG",
            "    putchar(c);",
            "#else",
            "    if (pp - pbuf == MAXSIZE) fwrite(pbuf, 1, MAXSIZE, stdout), pp = pbuf;",
            "    *pp++ = c;",
            "#endif",
            "  }",
            "",
            "  template <class T>",
            "  void write(T x) {",
            "    if (x < 0) x = -x, push('-');",
            "    static T sta[35];",
            "    int top = 0;",
            "    do {",
            "      sta[top++] = x % 10, x /= 10;",
            "    } while (x);",
            "    while (top) push(sta[--top] + '0');",
            "  }",
            "",
            "  template <class T>",
            "  void write(T x, char lastChar) {",
            "    write(x), push(lastChar);",
            "  }",
            "",
            "#ifdef ATCODER_MODINT_HPP",
            "  template <int m>",
            "  void write(static_modint<m> mx) { write(mx.val()); }",
            "  template <int id>",
            "  void write(dynamic_modint<id> mx) { write(mx.val()); }",
            "#endif",
            "} io;"
        ]
    },
    "mcmf": {
        "prefix": "mcmf",
        "scope": "cpp",
        "body": [
            "#include <algorithm>",
            "#include <cstdio>",
            "#include <cstring>",
            "#include <queue>",
            "",
            "// \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u6a21\u677f",
            "constexpr int N = 5e3 + 5, M = 1e5 + 5;  // N: \u6700\u5927\u8282\u70b9\u6570, M: \u6700\u5927\u8fb9\u6570",
            "constexpr int INF = 0x3f3f3f3f;          // \u65e0\u7a77\u5927",
            "",
            "// \u5168\u5c40\u53d8\u91cf\u5b9a\u4e49",
            "int n, m;           // n: \u8282\u70b9\u6570, m: \u8fb9\u6570",
            "int tot = 1;        // \u8fb9\u7684\u7f16\u53f7\uff0c\u4ece2\u5f00\u59cb\uff08\u65b9\u4fbf\u53d6\u53cd\u5411\u8fb9\uff09",
            "int lnk[N];         // \u90bb\u63a5\u8868\u5934\u8282\u70b9",
            "int cur[N];         // \u5f53\u524d\u5f27\u4f18\u5316\uff0c\u8bb0\u5f55\u6bcf\u4e2a\u8282\u70b9\u5f53\u524d\u641c\u7d22\u5230\u7684\u8fb9",
            "int ter[M];         // \u8fb9\u7684\u7ec8\u70b9",
            "int nxt[M];         // \u90bb\u63a5\u8868\u4e2d\u7684\u4e0b\u4e00\u6761\u8fb9",
            "int cap[M];         // \u8fb9\u7684\u5bb9\u91cf",
            "int cost[M];        // \u8fb9\u7684\u8d39\u7528",
            "int dis[N];         // SPFA\u4e2d\u7684\u6700\u77ed\u8def\u8ddd\u79bb",
            "int ret;            // \u603b\u8d39\u7528",
            "bool vis[N];        // \u8bbf\u95ee\u6807\u8bb0\u6570\u7ec4",
            "",
            "// \u6dfb\u52a0\u5355\u5411\u8fb9 u -> v\uff0c\u5bb9\u91cf\u4e3a w\uff0c\u8d39\u7528\u4e3a c",
            "void add(int u, int v, int w, int c) {",
            "  ter[++tot] = v;      // \u8fb9\u7684\u7ec8\u70b9",
            "  nxt[tot] = lnk[u];   // \u94fe\u63a5\u5230\u90bb\u63a5\u8868",
            "  lnk[u] = tot;        // \u66f4\u65b0\u5934\u8282\u70b9",
            "  cap[tot] = w;        // \u8bbe\u7f6e\u5bb9\u91cf",
            "  cost[tot] = c;       // \u8bbe\u7f6e\u8d39\u7528",
            "}",
            "",
            "// \u6dfb\u52a0\u53cc\u5411\u8fb9\uff1a\u6b63\u5411\u8fb9 u -> v (\u5bb9\u91cfw, \u8d39\u7528c) \u548c\u53cd\u5411\u8fb9 v -> u (\u5bb9\u91cf0, \u8d39\u7528-c)",
            "void addedge(int u, int v, int w, int c) {",
            "  add(u, v, w, c);     // \u6b63\u5411\u8fb9",
            "  add(v, u, 0, -c);    // \u53cd\u5411\u8fb9\uff0c\u5bb9\u91cf\u4e3a0\uff0c\u8d39\u7528\u4e3a\u8d1f",
            "}",
            "",
            "// \u4f7f\u7528 SPFA \u7b97\u6cd5\u5bfb\u627e\u4ece s \u5230 t \u7684\u6700\u77ed\u8def\u5f84\uff08\u8d39\u7528\u6700\u5c0f\u8def\u5f84\uff09",
            "bool spfa(int s, int t) {",
            "  memset(dis, 0x3f, sizeof(dis));    // \u521d\u59cb\u5316\u8ddd\u79bb\u4e3a\u65e0\u7a77\u5927",
            "  std::queue<int> q;",
            "  q.push(s);           // \u6e90\u70b9\u5165\u961f",
            "  dis[s] = 0;          // \u6e90\u70b9\u8ddd\u79bb\u4e3a0",
            "  vis[s] = true;       // \u6807\u8bb0\u6e90\u70b9\u5df2\u8bbf\u95ee",
            "",
            "  while (!q.empty()) {",
            "    int u = q.front();",
            "    q.pop();",
            "    vis[u] = false;    // \u51fa\u961f\u65f6\u53d6\u6d88\u8bbf\u95ee\u6807\u8bb0",
            "",
            "    // \u904d\u5386\u4ece\u8282\u70b9 u \u51fa\u53d1\u7684\u6240\u6709\u8fb9",
            "    for (int i = lnk[u]; i; i = nxt[i]) {",
            "      int v = ter[i];  // \u8fb9\u7684\u7ec8\u70b9",
            "      // \u5982\u679c\u8fb9\u6709\u5269\u4f59\u5bb9\u91cf\u4e14\u53ef\u4ee5\u677e\u5f1b\u8ddd\u79bb",
            "      if (cap[i] && dis[v] > dis[u] + cost[i]) {",
            "        dis[v] = dis[u] + cost[i];  // \u66f4\u65b0\u6700\u77ed\u8ddd\u79bb",
            "        if (!vis[v]) {              // \u5982\u679c\u8282\u70b9v\u4e0d\u5728\u961f\u5217\u4e2d",
            "          q.push(v);                // \u5c06v\u52a0\u5165\u961f\u5217",
            "          vis[v] = true;            // \u6807\u8bb0v\u5df2\u8bbf\u95ee",
            "        }",
            "      }",
            "    }",
            "  }",
            "  return dis[t] != INF;  // \u8fd4\u56de\u662f\u5426\u80fd\u5230\u8fbe\u7ec8\u70b9t",
            "}",
            "",
            "// \u4f7f\u7528 DFS \u5bfb\u627e\u589e\u5e7f\u8def\u5f84\u5e76\u8ba1\u7b97\u6700\u5927\u6d41\u91cf",
            "int dfs(int u, int t, int flow) {",
            "  if (u == t) return flow;  // \u5230\u8fbe\u7ec8\u70b9\uff0c\u8fd4\u56de\u5f53\u524d\u6d41\u91cf",
            "",
            "  vis[u] = true;            // \u6807\u8bb0\u5f53\u524d\u8282\u70b9\u5df2\u8bbf\u95ee",
            "  int ans = 0;              // \u4ece\u5f53\u524d\u8282\u70b9\u80fd\u589e\u5e7f\u7684\u603b\u6d41\u91cf",
            "",
            "  // \u904d\u5386\u4ece\u8282\u70b9u\u51fa\u53d1\u7684\u6240\u6709\u8fb9\uff08\u4f7f\u7528\u5f53\u524d\u5f27\u4f18\u5316\uff09",
            "  for (int &i = cur[u]; i && ans < flow; i = nxt[i]) {",
            "    int v = ter[i];         // \u8fb9\u7684\u7ec8\u70b9",
            "",
            "    // \u68c0\u67e5\u8fb9\u662f\u5426\u53ef\u4ee5\u589e\u5e7f\uff1a\u672a\u8bbf\u95ee\u3001\u6709\u5269\u4f59\u5bb9\u91cf\u3001\u5728\u6700\u77ed\u8def\u5f84\u4e0a",
            "    if (!vis[v] && cap[i] && dis[v] == dis[u] + cost[i]) {",
            "      // \u9012\u5f52\u641c\u7d22\uff0c\u6d41\u91cf\u4e3a\u5f53\u524d\u5269\u4f59\u5bb9\u91cf\u548c\u5269\u4f59\u9700\u6c42\u7684\u6700\u5c0f\u503c",
            "      int x = dfs(v, t, std::min(cap[i], flow - ans));",
            "",
            "      if (x) {              // \u5982\u679c\u627e\u5230\u4e86\u589e\u5e7f\u8def\u5f84",
            "        ret += x * cost[i]; // \u7d2f\u52a0\u8d39\u7528",
            "        cap[i] -= x;        // \u51cf\u5c11\u6b63\u5411\u8fb9\u5bb9\u91cf",
            "        cap[i ^ 1] += x;    // \u589e\u52a0\u53cd\u5411\u8fb9\u5bb9\u91cf",
            "        ans += x;           // \u7d2f\u52a0\u589e\u5e7f\u6d41\u91cf",
            "      }",
            "    }",
            "  }",
            "",
            "  vis[u] = false;           // \u56de\u6eaf\u65f6\u53d6\u6d88\u8bbf\u95ee\u6807\u8bb0",
            "  return ans;               // \u8fd4\u56de\u4ece\u5f53\u524d\u8282\u70b9\u589e\u5e7f\u7684\u603b\u6d41\u91cf",
            "}",
            "",
            "// \u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41\u4e3b\u7b97\u6cd5",
            "int mcmf(int s, int t) {",
            "  int ans = 0;              // \u6700\u5927\u6d41\u91cf",
            "",
            "  // \u5f53\u5b58\u5728\u4eces\u5230t\u7684\u589e\u5e7f\u8def\u5f84\u65f6\u7ee7\u7eed",
            "  while (spfa(s, t)) {",
            "    memcpy(cur, lnk, sizeof(lnk));  // \u91cd\u7f6e\u5f53\u524d\u5f27",
            "    int x;",
            "    // \u5728\u5f53\u524d\u8d39\u7528\u6700\u5c0f\u7684\u8def\u5f84\u4e0a\u5c3d\u53ef\u80fd\u591a\u5730\u589e\u5e7f",
            "    while ((x = dfs(s, t, INF))) {",
            "      ans += x;             // \u7d2f\u52a0\u6d41\u91cf",
            "    }",
            "  }",
            "",
            "  return ans;               // \u8fd4\u56de\u6700\u5927\u6d41\u91cf",
            "}",
            "",
            "int main() {",
            "  int s, t;",
            "  // \u8bfb\u5165\u8282\u70b9\u6570n\u3001\u8fb9\u6570m\u3001\u6e90\u70b9s\u3001\u6c47\u70b9t",
            "  scanf(\"%d%d%d%d\", &n, &m, &s, &t);",
            "",
            "  // \u8bfb\u5165m\u6761\u8fb9\u7684\u4fe1\u606f",
            "  while (m--) {",
            "    int u, v, w, c;",
            "    scanf(\"%d%d%d%d\", &u, &v, &w, &c);  // \u8d77\u70b9u\u3001\u7ec8\u70b9v\u3001\u5bb9\u91cfw\u3001\u8d39\u7528c",
            "    addedge(u, v, w, c);                 // \u6dfb\u52a0\u8fb9\u5230\u56fe\u4e2d",
            "  }",
            "",
            "  // \u8ba1\u7b97\u6700\u5c0f\u8d39\u7528\u6700\u5927\u6d41",
            "  int ans = mcmf(s, t);                  // ans\u4e3a\u6700\u5927\u6d41\u91cf",
            "  printf(\"%d %d\\n\", ans, ret);           // \u8f93\u51fa\u6700\u5927\u6d41\u91cf\u548c\u6700\u5c0f\u8d39\u7528",
            "",
            "  return 0;",
            "}"
        ]
    }
}